// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllHailReports = `-- name: GetAllHailReports :many
select rpt_type,
       reported_time,
       created_at,
       "size",
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from hail_reports
order by reported_time
`

func (q *Queries) GetAllHailReports(ctx context.Context) ([]HailReport, error) {
	rows, err := q.db.Query(ctx, getAllHailReports)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HailReport
	for rows.Next() {
		var i HailReport
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.Size,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllReports = `-- name: GetAllReports :many
select rpt_type,
       reported_time,
       created_at,
       var_col,
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from reports
order by reported_time,rpt_type
`

func (q *Queries) GetAllReports(ctx context.Context) ([]Report, error) {
	rows, err := q.db.Query(ctx, getAllReports)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Report
	for rows.Next() {
		var i Report
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.VarCol,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllReportsByDate = `-- name: GetAllReportsByDate :many
select rpt_type,
       reported_time,
       created_at,
       var_col,
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from reports
where reported_time = $1
order by reported_time, rpt_type
`

func (q *Queries) GetAllReportsByDate(ctx context.Context, reportedTime pgtype.Timestamptz) ([]Report, error) {
	rows, err := q.db.Query(ctx, getAllReportsByDate, reportedTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Report
	for rows.Next() {
		var i Report
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.VarCol,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllWindReports = `-- name: GetAllWindReports :many
select rpt_type,
       reported_time,
       created_at,
       speed,
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from wind_reports
order by reported_time
`

func (q *Queries) GetAllWindReports(ctx context.Context) ([]WindReport, error) {
	rows, err := q.db.Query(ctx, getAllWindReports)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WindReport
	for rows.Next() {
		var i WindReport
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.Speed,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHailReportsByCountyAndState = `-- name: GetHailReportsByCountyAndState :many
select rpt_type,
       reported_time,
       created_at,
       "size",
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from hail_reports
where county = $1
    AND "state" = $2
order by reported_time
`

type GetHailReportsByCountyAndStateParams struct {
	County string
	State  pgtype.Text
}

func (q *Queries) GetHailReportsByCountyAndState(ctx context.Context, arg GetHailReportsByCountyAndStateParams) ([]HailReport, error) {
	rows, err := q.db.Query(ctx, getHailReportsByCountyAndState, arg.County, arg.State)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HailReport
	for rows.Next() {
		var i HailReport
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.Size,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHailReportsByDate = `-- name: GetHailReportsByDate :many
select rpt_type,
       reported_time,
       created_at,
       "size",
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from hail_reports
where reported_time = $1
order by reported_time
`

func (q *Queries) GetHailReportsByDate(ctx context.Context, reportedTime pgtype.Timestamptz) ([]HailReport, error) {
	rows, err := q.db.Query(ctx, getHailReportsByDate, reportedTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HailReport
	for rows.Next() {
		var i HailReport
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.Size,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHailReportsByState = `-- name: GetHailReportsByState :many
select rpt_type,
       reported_time,
       created_at,
       "size",
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from hail_reports
where "state" = $1
order by reported_time
`

func (q *Queries) GetHailReportsByState(ctx context.Context, state pgtype.Text) ([]HailReport, error) {
	rows, err := q.db.Query(ctx, getHailReportsByState, state)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HailReport
	for rows.Next() {
		var i HailReport
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.Size,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportsByCountyAndState = `-- name: GetReportsByCountyAndState :many
select rpt_type,
       reported_time,
       created_at,
       var_col,
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from reports
where county = $1
    AND "state" = $2
order by reported_time,rpt_type
`

type GetReportsByCountyAndStateParams struct {
	County string
	State  pgtype.Text
}

func (q *Queries) GetReportsByCountyAndState(ctx context.Context, arg GetReportsByCountyAndStateParams) ([]Report, error) {
	rows, err := q.db.Query(ctx, getReportsByCountyAndState, arg.County, arg.State)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Report
	for rows.Next() {
		var i Report
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.VarCol,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportsByState = `-- name: GetReportsByState :many
select rpt_type,
       reported_time,
       created_at,
       var_col,
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from reports
where "state" = $1
order by reported_time,rpt_type
`

func (q *Queries) GetReportsByState(ctx context.Context, state pgtype.Text) ([]Report, error) {
	rows, err := q.db.Query(ctx, getReportsByState, state)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Report
	for rows.Next() {
		var i Report
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.VarCol,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTornadoReportsByCountyAndState = `-- name: GetTornadoReportsByCountyAndState :many
select rpt_type,
       reported_time,
       created_at,
       f_scale,
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from tornado_reports
where county = $1
    AND "state" = $2
order by reported_time
`

type GetTornadoReportsByCountyAndStateParams struct {
	County string
	State  pgtype.Text
}

func (q *Queries) GetTornadoReportsByCountyAndState(ctx context.Context, arg GetTornadoReportsByCountyAndStateParams) ([]TornadoReport, error) {
	rows, err := q.db.Query(ctx, getTornadoReportsByCountyAndState, arg.County, arg.State)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TornadoReport
	for rows.Next() {
		var i TornadoReport
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.FScale,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTornadoReportsByDate = `-- name: GetTornadoReportsByDate :many
select rpt_type,
       reported_time,
       created_at,
       f_scale,
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from tornado_reports
where reported_time = $1
order by reported_time
`

func (q *Queries) GetTornadoReportsByDate(ctx context.Context, reportedTime pgtype.Timestamptz) ([]TornadoReport, error) {
	rows, err := q.db.Query(ctx, getTornadoReportsByDate, reportedTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TornadoReport
	for rows.Next() {
		var i TornadoReport
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.FScale,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTornadoReportsByState = `-- name: GetTornadoReportsByState :many
select rpt_type,
       reported_time,
       created_at,
       f_scale,
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from tornado_reports
where "state" = $1
order by reported_time
`

func (q *Queries) GetTornadoReportsByState(ctx context.Context, state pgtype.Text) ([]TornadoReport, error) {
	rows, err := q.db.Query(ctx, getTornadoReportsByState, state)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TornadoReport
	for rows.Next() {
		var i TornadoReport
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.FScale,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWindReportsByCountyAndState = `-- name: GetWindReportsByCountyAndState :many
select rpt_type,
       reported_time,
       created_at,
       speed,
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from wind_reports
where county = $1
    AND "state" = $2
order by reported_time
`

type GetWindReportsByCountyAndStateParams struct {
	County string
	State  pgtype.Text
}

func (q *Queries) GetWindReportsByCountyAndState(ctx context.Context, arg GetWindReportsByCountyAndStateParams) ([]WindReport, error) {
	rows, err := q.db.Query(ctx, getWindReportsByCountyAndState, arg.County, arg.State)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WindReport
	for rows.Next() {
		var i WindReport
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.Speed,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWindReportsByDate = `-- name: GetWindReportsByDate :many
select rpt_type,
       reported_time,
       created_at,
       speed,
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from wind_reports
where reported_time = $1
order by reported_time
`

func (q *Queries) GetWindReportsByDate(ctx context.Context, reportedTime pgtype.Timestamptz) ([]WindReport, error) {
	rows, err := q.db.Query(ctx, getWindReportsByDate, reportedTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WindReport
	for rows.Next() {
		var i WindReport
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.Speed,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWindReportsByState = `-- name: GetWindReportsByState :many
select rpt_type,
       reported_time,
       created_at,
       speed,
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from wind_reports
where "state" = $1
order by reported_time
`

func (q *Queries) GetWindReportsByState(ctx context.Context, state pgtype.Text) ([]WindReport, error) {
	rows, err := q.db.Query(ctx, getWindReportsByState, state)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WindReport
	for rows.Next() {
		var i WindReport
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.Speed,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type InsertReportParams struct {
	RptType             ReportType
	ReportedTime        pgtype.Timestamptz
	CreatedAt           pgtype.Timestamptz
	VarCol              pgtype.Int4
	DistFromLocation    int32
	HeadingFromLocation string
	County              string
	State               pgtype.Text
	Latitude            pgtype.Text
	Longitude           pgtype.Text
	EventLocation       interface{}
	Comments            pgtype.Text
	NwsOffice           pgtype.Text
	Location            string
}
