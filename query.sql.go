// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllReports = `-- name: GetAllReports :many
select rpt_type,
       reported_time,
       created_at,
       var_col,
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from reports
order by reported_time
`

func (q *Queries) GetAllReports(ctx context.Context) ([]Report, error) {
	rows, err := q.db.Query(ctx, getAllReports)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Report
	for rows.Next() {
		var i Report
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.VarCol,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllReportsByDate = `-- name: GetAllReportsByDate :many
select rpt_type,
       reported_time,
       created_at,
       var_col,
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from reports
where reported_time = $1
order by reported_time
`

func (q *Queries) GetAllReportsByDate(ctx context.Context, reportedTime pgtype.Timestamptz) ([]Report, error) {
	rows, err := q.db.Query(ctx, getAllReportsByDate, reportedTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Report
	for rows.Next() {
		var i Report
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.VarCol,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllReportsByTypeByDate = `-- name: GetAllReportsByTypeByDate :many
select rpt_type,
       reported_time,
       created_at,
       var_col,
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from reports
where reported_time = $1
  AND rpt_type = $2
order by reported_time
`

type GetAllReportsByTypeByDateParams struct {
	ReportedTime pgtype.Timestamptz
	RptType      ReportType
}

func (q *Queries) GetAllReportsByTypeByDate(ctx context.Context, arg GetAllReportsByTypeByDateParams) ([]Report, error) {
	rows, err := q.db.Query(ctx, getAllReportsByTypeByDate, arg.ReportedTime, arg.RptType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Report
	for rows.Next() {
		var i Report
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.VarCol,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportsByCountyAndState = `-- name: GetReportsByCountyAndState :many
select rpt_type,
       reported_time,
       created_at,
       var_col,
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from reports
where county = $1
    AND "state" = $2
order by reported_time
`

type GetReportsByCountyAndStateParams struct {
	County string
	State  pgtype.Text
}

func (q *Queries) GetReportsByCountyAndState(ctx context.Context, arg GetReportsByCountyAndStateParams) ([]Report, error) {
	rows, err := q.db.Query(ctx, getReportsByCountyAndState, arg.County, arg.State)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Report
	for rows.Next() {
		var i Report
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.VarCol,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportsByState = `-- name: GetReportsByState :many
select rpt_type,
       reported_time,
       created_at,
       var_col,
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from reports
where "state" = $1
order by reported_time
`

func (q *Queries) GetReportsByState(ctx context.Context, state pgtype.Text) ([]Report, error) {
	rows, err := q.db.Query(ctx, getReportsByState, state)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Report
	for rows.Next() {
		var i Report
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.VarCol,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportsByType = `-- name: GetReportsByType :many
select rpt_type,
       reported_time,
       created_at,
       var_col,
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from reports
where rpt_type = $1
order by reported_time
`

func (q *Queries) GetReportsByType(ctx context.Context, rptType ReportType) ([]Report, error) {
	rows, err := q.db.Query(ctx, getReportsByType, rptType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Report
	for rows.Next() {
		var i Report
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.VarCol,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportsByTypeByCountyAndState = `-- name: GetReportsByTypeByCountyAndState :many
select rpt_type,
       reported_time,
       created_at,
       var_col,
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from reports
where county = $1
    AND "state" = $2
    AND rpt_type = $3
order by reported_time
`

type GetReportsByTypeByCountyAndStateParams struct {
	County  string
	State   pgtype.Text
	RptType ReportType
}

func (q *Queries) GetReportsByTypeByCountyAndState(ctx context.Context, arg GetReportsByTypeByCountyAndStateParams) ([]Report, error) {
	rows, err := q.db.Query(ctx, getReportsByTypeByCountyAndState, arg.County, arg.State, arg.RptType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Report
	for rows.Next() {
		var i Report
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.VarCol,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportsByTypeByState = `-- name: GetReportsByTypeByState :many
select rpt_type,
       reported_time,
       created_at,
       var_col,
       dist_from_location,
       heading_from_location,
       county,
       "state",
       latitude,
       longitude,
       event_location,
       comments,
       nws_office,
       location
from reports
where "state" = $1
    AND rpt_type = $2
order by reported_time
`

type GetReportsByTypeByStateParams struct {
	State   pgtype.Text
	RptType ReportType
}

func (q *Queries) GetReportsByTypeByState(ctx context.Context, arg GetReportsByTypeByStateParams) ([]Report, error) {
	rows, err := q.db.Query(ctx, getReportsByTypeByState, arg.State, arg.RptType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Report
	for rows.Next() {
		var i Report
		if err := rows.Scan(
			&i.RptType,
			&i.ReportedTime,
			&i.CreatedAt,
			&i.VarCol,
			&i.DistFromLocation,
			&i.HeadingFromLocation,
			&i.County,
			&i.State,
			&i.Latitude,
			&i.Longitude,
			&i.EventLocation,
			&i.Comments,
			&i.NwsOffice,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type InsertReportParams struct {
	RptType             ReportType
	ReportedTime        pgtype.Timestamptz
	CreatedAt           pgtype.Timestamptz
	VarCol              pgtype.Int4
	DistFromLocation    int32
	HeadingFromLocation string
	County              string
	State               pgtype.Text
	Latitude            pgtype.Text
	Longitude           pgtype.Text
	EventLocation       interface{}
	Comments            pgtype.Text
	NwsOffice           pgtype.Text
	Location            string
}
